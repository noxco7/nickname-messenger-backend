// =====================================================
// –§–ê–ô–õ: routes/auth.js (BACKEND) - FIXED REGISTRATION
// –ü–£–¢–¨: nickname-messenger-backend/routes/auth.js
// –¢–ò–ü: Node.js Backend
// –û–ü–ò–°–ê–ù–ò–ï: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Ä–æ—É—Ç —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å iOS
// =====================================================

const express = require('express');
const User = require('../models/User');
const TronValidation = require('../utils/TronValidation');
const { generateToken, authenticateToken } = require('../middleware/auth');
const router = express.Router();

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
router.post('/register', async (req, res) => {
    try {
        const { id, nickname, publicKey, tronAddress, firstName, lastName, avatar } = req.body;

        console.log(`üöÄ Registration request received:`);
        console.log(`   - ID: ${id}`);
        console.log(`   - Nickname: ${nickname}`);
        console.log(`   - TRON Address: ${tronAddress}`);

        // –í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
        if (!nickname || !publicKey || !tronAddress) {
            return res.status(400).json({
                error: 'Missing required fields: nickname, publicKey, tronAddress',
                code: 'MISSING_FIELDS'
            });
        }

        // –í–∞–ª–∏–¥–∞—Ü–∏—è nickname
        if (nickname.length < 3 || nickname.length > 20) {
            return res.status(400).json({
                error: 'Nickname must be between 3 and 20 characters',
                code: 'INVALID_NICKNAME'
            });
        }

        const nicknameRegex = /^[a-zA-Z0-9_]+$/;
        if (!nicknameRegex.test(nickname)) {
            return res.status(400).json({
                error: 'Nickname can only contain letters, numbers, and underscores',
                code: 'INVALID_NICKNAME_FORMAT'
            });
        }

        // –í–∞–ª–∏–¥–∞—Ü–∏—è TRON –∞–¥—Ä–µ—Å–∞
        if (!TronValidation.validateTronAddress(tronAddress)) {
            return res.status(400).json({
                error: 'Invalid TRON address format',
                code: 'INVALID_TRON_ADDRESS'
            });
        }

        // –ù–û–í–û–ï: –ü–æ–¥—Ä–æ–±–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–¥—Ä–µ—Å–µ
        const addressInfo = {
            isValid: true,
            isUSDTContract: tronAddress === 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            formatted: `${tronAddress.substring(0, 6)}...${tronAddress.substring(tronAddress.length - 6)}`,
            type: 'wallet'
        };

        console.log('‚úÖ TRON address validated:', addressInfo);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        const existingUser = await User.findOne({
            $or: [
                { nickname: nickname },
                { publicKey: publicKey },
                { tronAddress: tronAddress }
            ]
        });

        if (existingUser) {
            let field;
            if (existingUser.nickname === nickname) field = 'nickname';
            else if (existingUser.publicKey === publicKey) field = 'publicKey';
            else field = 'tronAddress';
            
            console.log(`‚ùå User already exists with ${field}`);
            return res.status(409).json({
                error: `User with this ${field} already exists`,
                code: 'USER_ALREADY_EXISTS',
                field: field
            });
        }

        // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å UUID
        const userData = {
            _id: id || require('crypto').randomUUID(),
            nickname,
            publicKey,
            tronAddress,
            firstName: firstName || '',
            lastName: lastName || '',
            avatar: avatar || null
        };

        const user = new User(userData);
        await user.save();

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º JWT —Ç–æ–∫–µ–Ω
        const token = generateToken(user._id);

        console.log('‚úÖ User registered successfully:', user.nickname);

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–æ–ª—è, –∫–æ—Ç–æ—Ä—ã–µ –æ–∂–∏–¥–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç
        res.status(201).json({
            message: 'User registered successfully',
            token: token,
            tokenType: 'Bearer',
            expiresIn: '7d',
            user: {
                id: user._id,
                _id: user._id,  // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –æ–±–∞ –ø–æ–ª—è
                nickname: user.nickname,
                publicKey: user.publicKey,
                tronAddress: user.tronAddress,
                tronAddressInfo: addressInfo,
                firstName: user.firstName,
                lastName: user.lastName,
                avatar: user.avatar,
                createdAt: user.createdAt
                // –£–ë–†–ê–ù–û: isOnline, lastSeen, updatedAt –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            }
        });

    } catch (error) {
        console.error('‚ùå Registration error:', error);
        res.status(500).json({ 
            error: 'Internal server error',
            code: 'INTERNAL_ERROR'
        });
    }
});

// –õ–æ–≥–∏–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
router.post('/login', async (req, res) => {
    try {
        const { nickname, publicKey } = req.body;

        console.log(`üîê Login request: ${nickname}`);

        if (!nickname || !publicKey) {
            return res.status(400).json({
                error: 'Missing required fields: nickname, publicKey',
                code: 'MISSING_FIELDS'
            });
        }

        // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const user = await User.findOne({ nickname });
        if (!user) {
            console.log('‚ùå User not found');
            return res.status(401).json({
                error: 'Invalid credentials',
                code: 'INVALID_CREDENTIALS'
            });
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á
        if (user.publicKey !== publicKey) {
            console.log('‚ùå Invalid public key');
            return res.status(401).json({
                error: 'Invalid credentials',
                code: 'INVALID_CREDENTIALS'
            });
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω
        user.isOnline = true;
        user.lastSeen = new Date();
        await user.save();

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω
        const token = generateToken(user._id);

        console.log('‚úÖ User logged in successfully:', user.nickname);

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –°–æ–≤–º–µ—Å—Ç–∏–º—ã–π –æ—Ç–≤–µ—Ç
        res.json({
            message: 'Login successful',
            token: token,
            tokenType: 'Bearer',
            expiresIn: '7d',
            user: {
                id: user._id,
                _id: user._id,
                nickname: user.nickname,
                publicKey: user.publicKey,
                tronAddress: user.tronAddress,
                firstName: user.firstName,
                lastName: user.lastName,
                avatar: user.avatar,
                createdAt: user.createdAt
                // –£–ë–†–ê–ù–û: isOnline, lastSeen –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            }
        });

    } catch (error) {
        console.error('‚ùå Login error:', error);
        res.status(500).json({ 
            error: 'Internal server error',
            code: 'INTERNAL_ERROR'
        });
    }
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ nickname
router.post('/check-nickname', async (req, res) => {
    try {
        const { nickname } = req.body;

        if (!nickname) {
            return res.status(400).json({
                error: 'Nickname is required',
                code: 'MISSING_NICKNAME'
            });
        }

        // –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª–∏–Ω—ã
        if (nickname.length < 3 || nickname.length > 20) {
            return res.status(400).json({
                error: 'Nickname must be between 3 and 20 characters',
                code: 'INVALID_LENGTH'
            });
        }

        // –í–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–æ—Ä–º–∞—Ç–∞
        const nicknameRegex = /^[a-zA-Z0-9_]+$/;
        if (!nicknameRegex.test(nickname)) {
            return res.status(400).json({
                error: 'Nickname can only contain letters, numbers, and underscores',
                code: 'INVALID_FORMAT'
            });
        }

        const existingUser = await User.findOne({ nickname });
        const available = !existingUser;

        console.log(`üîç Nickname check: ${nickname} - ${available ? 'Available' : 'Taken'}`);

        res.json({
            available: available,
            nickname: nickname
        });

    } catch (error) {
        console.error('‚ùå Nickname check error:', error);
        res.status(500).json({ 
            error: 'Internal server error',
            code: 'INTERNAL_ERROR'
        });
    }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ–∫—É—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ (–∑–∞—â–∏—â–µ–Ω–æ)
router.get('/me', authenticateToken, async (req, res) => {
    try {
        console.log(`üë§ Getting user info for: ${req.user.nickname}`);

        const user = await User.findById(req.user.id);
        if (!user) {
            return res.status(404).json({
                error: 'User not found',
                code: 'USER_NOT_FOUND'
            });
        }

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –°–æ–≤–º–µ—Å—Ç–∏–º—ã–π –æ—Ç–≤–µ—Ç
        res.json({
            user: {
                id: user._id,
                _id: user._id,
                nickname: user.nickname,
                publicKey: user.publicKey,
                tronAddress: user.tronAddress,
                firstName: user.firstName,
                lastName: user.lastName,
                avatar: user.avatar,
                createdAt: user.createdAt
            }
        });

    } catch (error) {
        console.error('‚ùå Get user info error:', error);
        res.status(500).json({ 
            error: 'Internal server error',
            code: 'INTERNAL_ERROR'
        });
    }
});

// –í—ã—Ö–æ–¥ (–∑–∞—â–∏—â–µ–Ω–æ)
router.post('/logout', authenticateToken, async (req, res) => {
    try {
        console.log(`üëã User logging out: ${req.user.nickname}`);

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await User.findByIdAndUpdate(req.user.id, {
            isOnline: false,
            lastSeen: new Date()
        });

        res.json({
            message: 'Logged out successfully'
        });

    } catch (error) {
        console.error('‚ùå Logout error:', error);
        res.status(500).json({ 
            error: 'Internal server error',
            code: 'INTERNAL_ERROR'
        });
    }
});

module.exports = router;